<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>Tilt API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Tilt</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/python

# Copyright (C) 2019 Lee C. Bussy (@LBussy)

# This file is part of LBussy&#39;s BrewPi Tilt Remix (BrewPi-Tilt-RMX).
#
# BrewPi Tilt RMX is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# BrewPi Tilt RMX is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with BrewPi Tilt RMX. If not, see &lt;https://www.gnu.org/licenses/&gt;.

# These scripts were originally a part of brewpi-brewometer, which provided
# support in BrewPi for the Tilt Electronic Hydrometer (formerly Brewometer.)

# Credit for the original brewpi-brewometer goes to @sibowler. @supercow
# then forked that work and released a more &#34;Legacy&#34;-capable version for
# the BrewPi Legacy users. This was an obvious jumping-off point for
# brewpi-tilt-rmx.

# As a derivative work of BrewPi, a project released under the GNU General
# Public License v3.0, this license is attached here giving precedence for
# prior work by the BrewPi team.  Both @sibowler and @supercow have agreed
# to this licensing approach.

from __future__ import print_function
#import blescan
import sys
import datetime
import time
import os
#import bluetooth._bluetooth as bluez
import threading
import _thread
import numpy
from scipy.interpolate import interp1d
from scipy import arange, array, exp
import csv
import functools
import configparser

TILT_COLORS = [&#39;Red&#39;, &#39;Green&#39;, &#39;Black&#39;, &#39;Purple&#39;, &#39;Orange&#39;, &#39;Blue&#39;, &#39;Yellow&#39;, &#39;Pink&#39;]

# Default time in seconds to wait before checking config files to see if
# calibration data has changed.
DATA_REFRESH_WINDOW = 60


def extrap1d(interpolator):
    &#34;&#34;&#34;
    Extrapolation of configuration points

    This function is required as the interp1d function doesn&#39;t support
    extrapolation in the version of scipy that is currently available on
    the pi.

    extrap1d Sourced from sastanin @ StackOverflow:
    http://stackoverflow.com/questions/2745329/

    :param interpolator: x/y dict containing values to be calibrated
    :return: x/y dict containing calibrated values
    &#34;&#34;&#34;

    xs = interpolator.x
    ys = interpolator.y

    def pointwise(x):
        if x &lt; xs[0]:
            return ys[0] + (x - xs[0]) * (ys[1] - ys[0]) / (xs[1] - xs[0])
        elif x &gt; xs[-1]:
            return ys[-1] + (x - xs[-1]) * (ys[-1] - ys[-2]) / (xs[-1] - xs[-2])
        else:
            return interpolator(x)

    def ufunclike(xs):
        return array(map(pointwise, array(xs)))

    return ufunclike


def offsetCalibration(offset, value):
    &#34;&#34;&#34;
    Simple offset calibration if only one point is available

    :param offset: Signed offset value
    :param value: Current value to be offset
    :return: Calibrated value
    &#34;&#34;&#34;

    return value + offset


def extrapolationCalibration(extrapolationFunction, value):
    &#34;&#34;&#34;
    Interpolation calibration if &gt;1 calibration point available
    Handles dispatch to appropriate extrapolation function

    :param extrapolationFunction: Function to be applied
    :param value: Current value to be offset
    :return: Calibrated value
    &#34;&#34;&#34;

    inputValue = [value]
    returnValue = extrapolationFunction(inputValue)
    return returnValue[0]


def noCalibration(value):
    &#34;&#34;&#34;
    Return unconverted argument if no calibration points available

    :param value: Current value to be offset
    :return: Calibrated value
    &#34;&#34;&#34;

    return value


def median(values):
    &#34;&#34;&#34;
    Returns median of supplied values

    :param values: Values to be calculated
    :return: Median of supplied values
    &#34;&#34;&#34;

    return numpy.median(numpy.array(values))


class TiltValue:
    &#34;&#34;&#34;
    Holds all category values of an individual Tilt reading
    &#34;&#34;&#34;

    temperature = 0
    gravity = 0
    timestamp = 0

    def __init__(self, temperature, gravity):
        self.temperature = temperature
        self.gravity = gravity
        self.timestamp = datetime.datetime.now()

    def __str__(self):
        return &#34;T: &#34; + str(self.temperature) + &#34; G: &#34; + str(self.gravity)


class Tilt:
    &#34;&#34;&#34;
    Manages Tilt values

    Handles calibration, storing of values and smoothing of read values.
    &#34;&#34;&#34;

    color = &#39;&#39;
    values = None
    lock = None
    averagingPeriod = 0
    medianWindow = 0
    calibrationDataTime = {}
    tempCal = None
    gravCal = None
    tempFunction = None
    gravityFunction = None

    def __init__(self, color, averagingPeriod=0, medianWindow=0):
        self.color = color
        self.lock = threading.Lock()
        self.averagingPeriod = averagingPeriod
        self.medianWindow = medianWindow
        self.values = []
        self.calibrate()
        self.calibrationDataTime = {
            &#39;temperature&#39;: 0,
            &#39;temperature_checked&#39;: 0,
            &#39;gravity&#39;: 0,
            &#39;gravity_checked&#39;: 0
        }

    def calibrate(self):
        &#34;&#34;&#34;Load/reload calibration functions.&#34;&#34;&#34;

        # Check for temperature function. If none, then not changed since
        # last load.
        self.tempFunction = self.tiltCal(&#34;temperature&#34;)
        if (self.tempFunction is not None):
            self.tempCal = self.tempFunction

        # Check for gravity function. If none, then not changed since last
        # load.
        self.gravityFunction = self.tiltCal(&#34;gravity&#34;)
        if (self.gravityFunction is not None):
            self.gravCal = self.gravityFunction

    def setValues(self, temp, grav):
        &#34;&#34;&#34;
        Set/add the latest temperature &amp; gravity readings to the store.

        These values will be calibrated before storing if calibration is
        enabled
        &#34;&#34;&#34;
        with self.lock:
            self.cleanValues()
            self.calibrate()
            calTemp = self.tempCal(temp)  # TODO: Fix this not working!
            calGrav = self.gravCal(grav)  # TODO: Fix this not working!
            # self.values.append(TiltValue(temp, grav))
            self.values.append(TiltValue(calTemp, calGrav))  # TODO: Fix this not working!

    def getValues(self):
        &#34;&#34;&#34;
        Returns the temperature &amp; gravity values of the Tilt.

        This will be the latest read value unless averaging / median has
        been enabled
        &#34;&#34;&#34;
        with self.lock:
            returnValue = None
            if (len(self.values) &gt; 0):
                if (self.medianWindow == 0):
                    returnValue = self.averageValues()
                else:
                    returnValue = self.medianValues(self.medianWindow)

                self.cleanValues()
        return returnValue

    def averageValues(self):
        &#34;&#34;&#34;
        Average all the stored values in the Tilt class

        :return:  Averaged values
        &#34;&#34;&#34;

        returnValue = None
        if (len(self.values) &gt; 0):
            returnValue = TiltValue(0, 0)
            for value in self.values:
                returnValue.temperature += value.temperature
                returnValue.gravity += value.gravity

            # Average values
            returnValue.temperature /= len(self.values)
            returnValue.gravity /= len(self.values)

            # Round values
            returnValue.temperature = returnValue.temperature
            returnValue.gravity = returnValue.gravity
        return returnValue

    def medianValues(self, window=3):
        &#34;&#34;&#34;
        Use a median method across the stored values to reduce noise


        :param window:  Smoothing window to apply across the data. If the
                        window is less than the dataset size, the window
                        will be moved across the dataset taking a median
                        value for each window, with the resultant set
                        averaged
        :return: Median value
        &#34;&#34;&#34;

        returnValue = None
        # Ensure there are enough values to do a median filter, if not shrink
        # window temporarily
        if (len(self.values) &lt; window):
            window = len(self.values)

        returnValue = TiltValue(0, 0)

        # sidebars = (window - 1) / 2
        medianValueCount = 0

        for i in range(len(self.values) - (window - 1)):
            # Work out range of values to do median. At start and end of
            # assessment, need to pad with start and end values.
            medianValues = self.values[i:i + window]
            medianValuesTemp = []
            medianValuesGravity = []

            # Separate out Temp and Gravity values
            for medianValue in medianValues:
                medianValuesTemp.append(medianValue.temperature)
                medianValuesGravity.append(medianValue.gravity)

            # Add the median value to the running total.
            returnValue.temperature += median(medianValuesTemp)
            returnValue.gravity += median(medianValuesGravity)

            # Increase count
            medianValueCount += 1

        # Average values
        returnValue.temperature /= medianValueCount
        returnValue.gravity /= medianValueCount

        # Round values
        returnValue.temperature = returnValue.temperature
        returnValue.gravity = returnValue.gravity

        return returnValue

    def cleanValues(self):
        &#34;&#34;&#34;
        Clean out stale values that are beyond the desired window

        :return: None, operates on values in class
        &#34;&#34;&#34;

        nowTime = datetime.datetime.now()

        for value in self.values:
            if ((nowTime - value.timestamp).seconds &gt;= self.averagingPeriod):
                self.values.pop(0)
            else:
                # The list is sorted in chronological order, so once we&#39;ve hit
                # this condition we can stop searching.
                break

    def tiltCal(self, which):
        &#34;&#34;&#34;
        Loads settings from file and create the calibration functions

        :param which: The calibration file to be processed
        :return: The calibration function to be called
        &#34;&#34;&#34;

        returnFunction = noCalibration

        originalValues = []
        actualValues = []
        csvFile = None
        path = os.path.dirname(os.path.abspath(__file__))
        configDir = &#39;{0}/settings/&#39;.format(path)
        filename = &#39;{0}{1}.{2}&#39;.format(configDir, which.upper(), self.color.lower())

        lastChecked = self.calibrationDataTime.get(which + &#34;_checked&#34;, 0)
        if ((int(time.time()) - lastChecked) &lt; DATA_REFRESH_WINDOW):
            # Only check every DATA_REFRESH_WINDOW seconds
            return None

        lastLoaded = self.calibrationDataTime.get(which, 0)
        self.calibrationDataTime[which + &#34;_checked&#34;] = int(time.time())

        try:
            if (os.path.isfile(filename)):
                fileModificationTime = os.path.getmtime(filename)
                if (lastLoaded &gt;= fileModificationTime):
                    # No need to load, no change
                    return None
                csvFile = open(filename, &#34;rb&#34;)
                csvFileReader = csv.reader(csvFile, skipinitialspace=True)
                self.calibrationDataTime[which] = fileModificationTime

                for row in csvFileReader:
                    # Skip any blank or comment rows
                    if (row != [] and row[0][:1] != &#34;#&#34;):
                        originalValues.append(float(row[0]))
                        actualValues.append(float(row[1]))
                # Close file
                csvFile.close()
        except IOError:
            print(&#39;Tilt ({0}): {1}: No calibration data ({2})&#39;.format(
                self.color, which.capitalize(), filename))
        except Exception as e:
            print(&#39;ERROR: Tilt ({0}): Unable to initialise {1} calibration data ({2}) - {3}&#39;.format(
                self.color, which.capitalize(), filename, e.message))
            # Attempt to close the file
            if (csvFile is not None):
                # Close file
                csvFile.close()

        # If more than two values, use interpolation
        if (len(actualValues) &gt;= 2):
            interpolationFunction = interp1d(originalValues, actualValues, bounds_error=False, fill_value=1)
            returnFunction = functools.partial(extrapolationCalibration, extrap1d(interpolationFunction))
            print(&#39;Tilt ({0}): Initialized {1} Calibration: Interpolation&#39;.format(self.color, which.capitalize()))
        # Not enough values. Likely just an offset calculation
        elif (len(actualValues) == 1):
            offset = actualValues[0] - originalValues[0]
            returnFunction = functools.partial(offsetCalibration, offset)
            print(&#39;Tilt ({0}): Initialized {1} Calibration: Offset ({2})&#39;.format(self.color, which.capitalize(),
                                                                                 str(offset)))
        return returnFunction


class TiltManager:
    &#34;&#34;&#34;
    Manages the monitoring of all Tilts and storing the read values
    &#34;&#34;&#34;

    color = &#39;&#39;
    dev_id = 0
    averagingPeriod = 0
    medianWindow = 0
    tilt = None
    scanning = True
    tiltthread = None

    def __init__(self, color, averagingPeriod = 0, medianWindow = 0, dev_id = 0):
        &#34;&#34;&#34;
        Initializes TiltManager class with default values

        :param color: Tilt color to be managed
        :param averagingPeriod: Time period in seconds for noise smoothing
        :param medianWindow: Median filter setting in number of  entries
        :param dev_id: Device ID of the local Bluetooth device to use
        &#34;&#34;&#34;
        self.color = color
        self.dev_id = dev_id
        self.averagingPeriod = averagingPeriod
        self.medianWindow = medianWindow
        self.tilt = Tilt(color, self.averagingPeriod, self.medianWindow)

    def tiltName(self, uuid):
        &#34;&#34;&#34;
        Return Tilt color given UUID

        :param uuid: UUID from BLEacon
        :return: Tilt color
        &#34;&#34;&#34;

        return {
            &#39;a495bb10c5b14b44b5121370f02d74de&#39;: &#39;Red&#39;,
            &#39;a495bb20c5b14b44b5121370f02d74de&#39;: &#39;Green&#39;,
            &#39;a495bb30c5b14b44b5121370f02d74de&#39;: &#39;Black&#39;,
            &#39;a495bb40c5b14b44b5121370f02d74de&#39;: &#39;Purple&#39;,
            &#39;a495bb50c5b14b44b5121370f02d74de&#39;: &#39;Orange&#39;,
            &#39;a495bb60c5b14b44b5121370f02d74de&#39;: &#39;Blue&#39;,
            &#39;a495bb70c5b14b44b5121370f02d74de&#39;: &#39;Yellow&#39;,
            &#39;a495bb80c5b14b44b5121370f02d74de&#39;: &#39;Pink&#39;
        }.get(uuid)

    def storeValue(self, temperature, gravity):
        &#34;&#34;&#34;
        Store Tilt values

        :param temperature: Temperature value to be stored
        :param gravity: Gravity value to be stored
        :return: None
        &#34;&#34;&#34;

        self.tilt.setValues(temperature, gravity)

    def getValue(self):
        &#34;&#34;&#34;
        Retrieve Tilt value

        :return: Tilt value
        &#34;&#34;&#34;

        returnValue = None
        returnValue = self.tilt.getValues()
        return returnValue

    def scan(self):
        &#34;&#34;&#34;
        Scan for BLE messages, store as Tilt values

        :return: None
        &#34;&#34;&#34;

        try:
            sock = bluez.hci_open_dev(self.dev_id)

        except Exception as e:
            print(
                &#39;ERROR: Unable to access Bluetooth device: {0}&#39;.format(e.message))
            sys.exit(1)

        blescan.hci_le_set_scan_parameters(sock)
        blescan.hci_enable_le_scan(sock)

        # Keep scanning until the manager is told to stop.
        while self.scanning:

            returnedList = blescan.parse_events(sock, 10)

            for beacon in returnedList:
                beaconParts = beacon.split(&#34;,&#34;)

                # If the event is for our Tilt, process the data
                if self.tiltName(beaconParts[2]) == self.color:
                    # color = self.color
                    # ts = beaconParts[0]
                    # mac = beaconParts[1]
                    # uuid = beaconParts[2]
                    # temp = beaconParts[3]
                    # grav = beaconParts[4]
                    # txp = beaconParts[5]
                    # rssi = beaconParts[6]

                    # Get the temperature (in F, conversion in brewpi.py)
                    temperature = int(beaconParts[3])

                    # Get the gravity
                    gravity = float(beaconParts[4]) / 1000

                    # Store the retrieved values in the relevant Tilt object.
                    self.storeValue(temperature, gravity)

    def stop(self):
        &#34;&#34;&#34;
        Stop the BLE scanning thread
        :return:
        &#34;&#34;&#34;

        self.scanning = False

    def start(self):
        &#34;&#34;&#34;
        Starts the BLE scanning thread

        :return: None
        &#34;&#34;&#34;

        self.scanning = True
        self.tiltthread = thread.start_new_thread(self.scan, ())

    def loadSettings(self):
        &#34;&#34;&#34;
        Load Settings from config file

        Overrides values given at creation. This needs to be called before
        the start function is called.

        :return: None
        &#34;&#34;&#34;

        myDir = os.path.dirname(os.path.abspath(__file__))
        filename = &#39;{0}/settings/tiltsettings.ini&#39;.format(myDir)
        try:
            config = ConfigParser.ConfigParser()
            config.read(filename)

            # BT Device ID
            try:
                self.dev_id = config.getint(&#34;Manager&#34;, &#34;DeviceID&#34;)
            except:
                pass

            # Time period for noise smoothing
            try:
                self.averagingPeriod = config.getint(&#34;Manager&#34;, &#34;AvgWindow&#34;)
            except:
                pass

            # Median filter setting
            try:
                self.medianWindow = config.getint(&#34;Manager&#34;, &#34;MedWindow&#34;)
            except:
                pass

        except Exception as e:
            print(&#39;WARN: Config file does not exist or cannot be read: ({0}): {1}&#39;.format(filename, e.message))


def main():
    &#34;&#34;&#34;
    Test function executed when run as a discrete script

    :return: None
    &#34;&#34;&#34;
    &#39;&#39;&#39;Test run for stand-alone run.&#39;&#39;&#39;
    threads = []
    tiltList = []

    for color in TILT_COLORS:
        color = TiltManager(color)
        tiltList.append(color)
        color.loadSettings()
        color.start()

    print(&#39;\nScanning Tilt for 20 Secs (Control+C to exit early).&#39;)
    for x in range(4):
        time.sleep(5)
        print(&#39;\nLoop Iteration: {0}&#39;.format(x + 1))
        for tilt in tiltList:
            print(&#39;{0}: {1}&#39;.format(tilt.color, str(tilt.getValue())))

    for tilt in tiltList:
        tilt.stop()

    for thread in threads:
        time.sleep(2)
        thread.join()


if __name__ == &#34;__main__&#34;:
    &#34;&#34;&#34;
    Called main() when run as a discrete script
    &#34;&#34;&#34;
    main()
    exit(0)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="Tilt.extrap1d"><code class="name flex">
<span>def <span class="ident">extrap1d</span></span>(<span>interpolator)</span>
</code></dt>
<dd>
<section class="desc"><p>Extrapolation of configuration points</p>
<p>This function is required as the interp1d function doesn't support
extrapolation in the version of scipy that is currently available on
the pi.</p>
<p>extrap1d Sourced from sastanin @ StackOverflow:
<a href="http://stackoverflow.com/questions/2745329/">http://stackoverflow.com/questions/2745329/</a></p>
<p>:param interpolator: x/y dict containing values to be calibrated
:return: x/y dict containing calibrated values</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extrap1d(interpolator):
    &#34;&#34;&#34;
    Extrapolation of configuration points

    This function is required as the interp1d function doesn&#39;t support
    extrapolation in the version of scipy that is currently available on
    the pi.

    extrap1d Sourced from sastanin @ StackOverflow:
    http://stackoverflow.com/questions/2745329/

    :param interpolator: x/y dict containing values to be calibrated
    :return: x/y dict containing calibrated values
    &#34;&#34;&#34;

    xs = interpolator.x
    ys = interpolator.y

    def pointwise(x):
        if x &lt; xs[0]:
            return ys[0] + (x - xs[0]) * (ys[1] - ys[0]) / (xs[1] - xs[0])
        elif x &gt; xs[-1]:
            return ys[-1] + (x - xs[-1]) * (ys[-1] - ys[-2]) / (xs[-1] - xs[-2])
        else:
            return interpolator(x)

    def ufunclike(xs):
        return array(map(pointwise, array(xs)))

    return ufunclike</code></pre>
</details>
</dd>
<dt id="Tilt.extrapolationCalibration"><code class="name flex">
<span>def <span class="ident">extrapolationCalibration</span></span>(<span>extrapolationFunction, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Interpolation calibration if &gt;1 calibration point available
Handles dispatch to appropriate extrapolation function</p>
<p>:param extrapolationFunction: Function to be applied
:param value: Current value to be offset
:return: Calibrated value</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extrapolationCalibration(extrapolationFunction, value):
    &#34;&#34;&#34;
    Interpolation calibration if &gt;1 calibration point available
    Handles dispatch to appropriate extrapolation function

    :param extrapolationFunction: Function to be applied
    :param value: Current value to be offset
    :return: Calibrated value
    &#34;&#34;&#34;

    inputValue = [value]
    returnValue = extrapolationFunction(inputValue)
    return returnValue[0]</code></pre>
</details>
</dd>
<dt id="Tilt.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Test function executed when run as a discrete script</p>
<p>:return: None</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    &#34;&#34;&#34;
    Test function executed when run as a discrete script

    :return: None
    &#34;&#34;&#34;
    &#39;&#39;&#39;Test run for stand-alone run.&#39;&#39;&#39;
    threads = []
    tiltList = []

    for color in TILT_COLORS:
        color = TiltManager(color)
        tiltList.append(color)
        color.loadSettings()
        color.start()

    print(&#39;\nScanning Tilt for 20 Secs (Control+C to exit early).&#39;)
    for x in range(4):
        time.sleep(5)
        print(&#39;\nLoop Iteration: {0}&#39;.format(x + 1))
        for tilt in tiltList:
            print(&#39;{0}: {1}&#39;.format(tilt.color, str(tilt.getValue())))

    for tilt in tiltList:
        tilt.stop()

    for thread in threads:
        time.sleep(2)
        thread.join()</code></pre>
</details>
</dd>
<dt id="Tilt.median"><code class="name flex">
<span>def <span class="ident">median</span></span>(<span>values)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns median of supplied values</p>
<p>:param values: Values to be calculated
:return: Median of supplied values</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def median(values):
    &#34;&#34;&#34;
    Returns median of supplied values

    :param values: Values to be calculated
    :return: Median of supplied values
    &#34;&#34;&#34;

    return numpy.median(numpy.array(values))</code></pre>
</details>
</dd>
<dt id="Tilt.noCalibration"><code class="name flex">
<span>def <span class="ident">noCalibration</span></span>(<span>value)</span>
</code></dt>
<dd>
<section class="desc"><p>Return unconverted argument if no calibration points available</p>
<p>:param value: Current value to be offset
:return: Calibrated value</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def noCalibration(value):
    &#34;&#34;&#34;
    Return unconverted argument if no calibration points available

    :param value: Current value to be offset
    :return: Calibrated value
    &#34;&#34;&#34;

    return value</code></pre>
</details>
</dd>
<dt id="Tilt.offsetCalibration"><code class="name flex">
<span>def <span class="ident">offsetCalibration</span></span>(<span>offset, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Simple offset calibration if only one point is available</p>
<p>:param offset: Signed offset value
:param value: Current value to be offset
:return: Calibrated value</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def offsetCalibration(offset, value):
    &#34;&#34;&#34;
    Simple offset calibration if only one point is available

    :param offset: Signed offset value
    :param value: Current value to be offset
    :return: Calibrated value
    &#34;&#34;&#34;

    return value + offset</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Tilt.Tilt"><code class="flex name class">
<span>class <span class="ident">Tilt</span></span>
<span>(</span><span>color, averagingPeriod=0, medianWindow=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Manages Tilt values</p>
<p>Handles calibration, storing of values and smoothing of read values.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tilt:
    &#34;&#34;&#34;
    Manages Tilt values

    Handles calibration, storing of values and smoothing of read values.
    &#34;&#34;&#34;

    color = &#39;&#39;
    values = None
    lock = None
    averagingPeriod = 0
    medianWindow = 0
    calibrationDataTime = {}
    tempCal = None
    gravCal = None
    tempFunction = None
    gravityFunction = None

    def __init__(self, color, averagingPeriod=0, medianWindow=0):
        self.color = color
        self.lock = threading.Lock()
        self.averagingPeriod = averagingPeriod
        self.medianWindow = medianWindow
        self.values = []
        self.calibrate()
        self.calibrationDataTime = {
            &#39;temperature&#39;: 0,
            &#39;temperature_checked&#39;: 0,
            &#39;gravity&#39;: 0,
            &#39;gravity_checked&#39;: 0
        }

    def calibrate(self):
        &#34;&#34;&#34;Load/reload calibration functions.&#34;&#34;&#34;

        # Check for temperature function. If none, then not changed since
        # last load.
        self.tempFunction = self.tiltCal(&#34;temperature&#34;)
        if (self.tempFunction is not None):
            self.tempCal = self.tempFunction

        # Check for gravity function. If none, then not changed since last
        # load.
        self.gravityFunction = self.tiltCal(&#34;gravity&#34;)
        if (self.gravityFunction is not None):
            self.gravCal = self.gravityFunction

    def setValues(self, temp, grav):
        &#34;&#34;&#34;
        Set/add the latest temperature &amp; gravity readings to the store.

        These values will be calibrated before storing if calibration is
        enabled
        &#34;&#34;&#34;
        with self.lock:
            self.cleanValues()
            self.calibrate()
            calTemp = self.tempCal(temp)  # TODO: Fix this not working!
            calGrav = self.gravCal(grav)  # TODO: Fix this not working!
            # self.values.append(TiltValue(temp, grav))
            self.values.append(TiltValue(calTemp, calGrav))  # TODO: Fix this not working!

    def getValues(self):
        &#34;&#34;&#34;
        Returns the temperature &amp; gravity values of the Tilt.

        This will be the latest read value unless averaging / median has
        been enabled
        &#34;&#34;&#34;
        with self.lock:
            returnValue = None
            if (len(self.values) &gt; 0):
                if (self.medianWindow == 0):
                    returnValue = self.averageValues()
                else:
                    returnValue = self.medianValues(self.medianWindow)

                self.cleanValues()
        return returnValue

    def averageValues(self):
        &#34;&#34;&#34;
        Average all the stored values in the Tilt class

        :return:  Averaged values
        &#34;&#34;&#34;

        returnValue = None
        if (len(self.values) &gt; 0):
            returnValue = TiltValue(0, 0)
            for value in self.values:
                returnValue.temperature += value.temperature
                returnValue.gravity += value.gravity

            # Average values
            returnValue.temperature /= len(self.values)
            returnValue.gravity /= len(self.values)

            # Round values
            returnValue.temperature = returnValue.temperature
            returnValue.gravity = returnValue.gravity
        return returnValue

    def medianValues(self, window=3):
        &#34;&#34;&#34;
        Use a median method across the stored values to reduce noise


        :param window:  Smoothing window to apply across the data. If the
                        window is less than the dataset size, the window
                        will be moved across the dataset taking a median
                        value for each window, with the resultant set
                        averaged
        :return: Median value
        &#34;&#34;&#34;

        returnValue = None
        # Ensure there are enough values to do a median filter, if not shrink
        # window temporarily
        if (len(self.values) &lt; window):
            window = len(self.values)

        returnValue = TiltValue(0, 0)

        # sidebars = (window - 1) / 2
        medianValueCount = 0

        for i in range(len(self.values) - (window - 1)):
            # Work out range of values to do median. At start and end of
            # assessment, need to pad with start and end values.
            medianValues = self.values[i:i + window]
            medianValuesTemp = []
            medianValuesGravity = []

            # Separate out Temp and Gravity values
            for medianValue in medianValues:
                medianValuesTemp.append(medianValue.temperature)
                medianValuesGravity.append(medianValue.gravity)

            # Add the median value to the running total.
            returnValue.temperature += median(medianValuesTemp)
            returnValue.gravity += median(medianValuesGravity)

            # Increase count
            medianValueCount += 1

        # Average values
        returnValue.temperature /= medianValueCount
        returnValue.gravity /= medianValueCount

        # Round values
        returnValue.temperature = returnValue.temperature
        returnValue.gravity = returnValue.gravity

        return returnValue

    def cleanValues(self):
        &#34;&#34;&#34;
        Clean out stale values that are beyond the desired window

        :return: None, operates on values in class
        &#34;&#34;&#34;

        nowTime = datetime.datetime.now()

        for value in self.values:
            if ((nowTime - value.timestamp).seconds &gt;= self.averagingPeriod):
                self.values.pop(0)
            else:
                # The list is sorted in chronological order, so once we&#39;ve hit
                # this condition we can stop searching.
                break

    def tiltCal(self, which):
        &#34;&#34;&#34;
        Loads settings from file and create the calibration functions

        :param which: The calibration file to be processed
        :return: The calibration function to be called
        &#34;&#34;&#34;

        returnFunction = noCalibration

        originalValues = []
        actualValues = []
        csvFile = None
        path = os.path.dirname(os.path.abspath(__file__))
        configDir = &#39;{0}/settings/&#39;.format(path)
        filename = &#39;{0}{1}.{2}&#39;.format(configDir, which.upper(), self.color.lower())

        lastChecked = self.calibrationDataTime.get(which + &#34;_checked&#34;, 0)
        if ((int(time.time()) - lastChecked) &lt; DATA_REFRESH_WINDOW):
            # Only check every DATA_REFRESH_WINDOW seconds
            return None

        lastLoaded = self.calibrationDataTime.get(which, 0)
        self.calibrationDataTime[which + &#34;_checked&#34;] = int(time.time())

        try:
            if (os.path.isfile(filename)):
                fileModificationTime = os.path.getmtime(filename)
                if (lastLoaded &gt;= fileModificationTime):
                    # No need to load, no change
                    return None
                csvFile = open(filename, &#34;rb&#34;)
                csvFileReader = csv.reader(csvFile, skipinitialspace=True)
                self.calibrationDataTime[which] = fileModificationTime

                for row in csvFileReader:
                    # Skip any blank or comment rows
                    if (row != [] and row[0][:1] != &#34;#&#34;):
                        originalValues.append(float(row[0]))
                        actualValues.append(float(row[1]))
                # Close file
                csvFile.close()
        except IOError:
            print(&#39;Tilt ({0}): {1}: No calibration data ({2})&#39;.format(
                self.color, which.capitalize(), filename))
        except Exception as e:
            print(&#39;ERROR: Tilt ({0}): Unable to initialise {1} calibration data ({2}) - {3}&#39;.format(
                self.color, which.capitalize(), filename, e.message))
            # Attempt to close the file
            if (csvFile is not None):
                # Close file
                csvFile.close()

        # If more than two values, use interpolation
        if (len(actualValues) &gt;= 2):
            interpolationFunction = interp1d(originalValues, actualValues, bounds_error=False, fill_value=1)
            returnFunction = functools.partial(extrapolationCalibration, extrap1d(interpolationFunction))
            print(&#39;Tilt ({0}): Initialized {1} Calibration: Interpolation&#39;.format(self.color, which.capitalize()))
        # Not enough values. Likely just an offset calculation
        elif (len(actualValues) == 1):
            offset = actualValues[0] - originalValues[0]
            returnFunction = functools.partial(offsetCalibration, offset)
            print(&#39;Tilt ({0}): Initialized {1} Calibration: Offset ({2})&#39;.format(self.color, which.capitalize(),
                                                                                 str(offset)))
        return returnFunction</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="Tilt.Tilt.averagingPeriod"><code class="name">var <span class="ident">averagingPeriod</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="Tilt.Tilt.calibrationDataTime"><code class="name">var <span class="ident">calibrationDataTime</span></code></dt>
<dd>
<section class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></section>
</dd>
<dt id="Tilt.Tilt.color"><code class="name">var <span class="ident">color</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
<dt id="Tilt.Tilt.gravCal"><code class="name">var <span class="ident">gravCal</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="Tilt.Tilt.gravityFunction"><code class="name">var <span class="ident">gravityFunction</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="Tilt.Tilt.lock"><code class="name">var <span class="ident">lock</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="Tilt.Tilt.medianWindow"><code class="name">var <span class="ident">medianWindow</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="Tilt.Tilt.tempCal"><code class="name">var <span class="ident">tempCal</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="Tilt.Tilt.tempFunction"><code class="name">var <span class="ident">tempFunction</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="Tilt.Tilt.values"><code class="name">var <span class="ident">values</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Tilt.Tilt.averageValues"><code class="name flex">
<span>def <span class="ident">averageValues</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Average all the stored values in the Tilt class</p>
<p>:return:
Averaged values</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def averageValues(self):
    &#34;&#34;&#34;
    Average all the stored values in the Tilt class

    :return:  Averaged values
    &#34;&#34;&#34;

    returnValue = None
    if (len(self.values) &gt; 0):
        returnValue = TiltValue(0, 0)
        for value in self.values:
            returnValue.temperature += value.temperature
            returnValue.gravity += value.gravity

        # Average values
        returnValue.temperature /= len(self.values)
        returnValue.gravity /= len(self.values)

        # Round values
        returnValue.temperature = returnValue.temperature
        returnValue.gravity = returnValue.gravity
    return returnValue</code></pre>
</details>
</dd>
<dt id="Tilt.Tilt.calibrate"><code class="name flex">
<span>def <span class="ident">calibrate</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Load/reload calibration functions.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calibrate(self):
    &#34;&#34;&#34;Load/reload calibration functions.&#34;&#34;&#34;

    # Check for temperature function. If none, then not changed since
    # last load.
    self.tempFunction = self.tiltCal(&#34;temperature&#34;)
    if (self.tempFunction is not None):
        self.tempCal = self.tempFunction

    # Check for gravity function. If none, then not changed since last
    # load.
    self.gravityFunction = self.tiltCal(&#34;gravity&#34;)
    if (self.gravityFunction is not None):
        self.gravCal = self.gravityFunction</code></pre>
</details>
</dd>
<dt id="Tilt.Tilt.cleanValues"><code class="name flex">
<span>def <span class="ident">cleanValues</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Clean out stale values that are beyond the desired window</p>
<p>:return: None, operates on values in class</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleanValues(self):
    &#34;&#34;&#34;
    Clean out stale values that are beyond the desired window

    :return: None, operates on values in class
    &#34;&#34;&#34;

    nowTime = datetime.datetime.now()

    for value in self.values:
        if ((nowTime - value.timestamp).seconds &gt;= self.averagingPeriod):
            self.values.pop(0)
        else:
            # The list is sorted in chronological order, so once we&#39;ve hit
            # this condition we can stop searching.
            break</code></pre>
</details>
</dd>
<dt id="Tilt.Tilt.getValues"><code class="name flex">
<span>def <span class="ident">getValues</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the temperature &amp; gravity values of the Tilt.</p>
<p>This will be the latest read value unless averaging / median has
been enabled</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getValues(self):
    &#34;&#34;&#34;
    Returns the temperature &amp; gravity values of the Tilt.

    This will be the latest read value unless averaging / median has
    been enabled
    &#34;&#34;&#34;
    with self.lock:
        returnValue = None
        if (len(self.values) &gt; 0):
            if (self.medianWindow == 0):
                returnValue = self.averageValues()
            else:
                returnValue = self.medianValues(self.medianWindow)

            self.cleanValues()
    return returnValue</code></pre>
</details>
</dd>
<dt id="Tilt.Tilt.medianValues"><code class="name flex">
<span>def <span class="ident">medianValues</span></span>(<span>self, window=3)</span>
</code></dt>
<dd>
<section class="desc"><p>Use a median method across the stored values to reduce noise</p>
<p>:param window:
Smoothing window to apply across the data. If the
window is less than the dataset size, the window
will be moved across the dataset taking a median
value for each window, with the resultant set
averaged
:return: Median value</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def medianValues(self, window=3):
    &#34;&#34;&#34;
    Use a median method across the stored values to reduce noise


    :param window:  Smoothing window to apply across the data. If the
                    window is less than the dataset size, the window
                    will be moved across the dataset taking a median
                    value for each window, with the resultant set
                    averaged
    :return: Median value
    &#34;&#34;&#34;

    returnValue = None
    # Ensure there are enough values to do a median filter, if not shrink
    # window temporarily
    if (len(self.values) &lt; window):
        window = len(self.values)

    returnValue = TiltValue(0, 0)

    # sidebars = (window - 1) / 2
    medianValueCount = 0

    for i in range(len(self.values) - (window - 1)):
        # Work out range of values to do median. At start and end of
        # assessment, need to pad with start and end values.
        medianValues = self.values[i:i + window]
        medianValuesTemp = []
        medianValuesGravity = []

        # Separate out Temp and Gravity values
        for medianValue in medianValues:
            medianValuesTemp.append(medianValue.temperature)
            medianValuesGravity.append(medianValue.gravity)

        # Add the median value to the running total.
        returnValue.temperature += median(medianValuesTemp)
        returnValue.gravity += median(medianValuesGravity)

        # Increase count
        medianValueCount += 1

    # Average values
    returnValue.temperature /= medianValueCount
    returnValue.gravity /= medianValueCount

    # Round values
    returnValue.temperature = returnValue.temperature
    returnValue.gravity = returnValue.gravity

    return returnValue</code></pre>
</details>
</dd>
<dt id="Tilt.Tilt.setValues"><code class="name flex">
<span>def <span class="ident">setValues</span></span>(<span>self, temp, grav)</span>
</code></dt>
<dd>
<section class="desc"><p>Set/add the latest temperature &amp; gravity readings to the store.</p>
<p>These values will be calibrated before storing if calibration is
enabled</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setValues(self, temp, grav):
    &#34;&#34;&#34;
    Set/add the latest temperature &amp; gravity readings to the store.

    These values will be calibrated before storing if calibration is
    enabled
    &#34;&#34;&#34;
    with self.lock:
        self.cleanValues()
        self.calibrate()
        calTemp = self.tempCal(temp)  # TODO: Fix this not working!
        calGrav = self.gravCal(grav)  # TODO: Fix this not working!
        # self.values.append(TiltValue(temp, grav))
        self.values.append(TiltValue(calTemp, calGrav))  # TODO: Fix this not working!</code></pre>
</details>
</dd>
<dt id="Tilt.Tilt.tiltCal"><code class="name flex">
<span>def <span class="ident">tiltCal</span></span>(<span>self, which)</span>
</code></dt>
<dd>
<section class="desc"><p>Loads settings from file and create the calibration functions</p>
<p>:param which: The calibration file to be processed
:return: The calibration function to be called</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tiltCal(self, which):
    &#34;&#34;&#34;
    Loads settings from file and create the calibration functions

    :param which: The calibration file to be processed
    :return: The calibration function to be called
    &#34;&#34;&#34;

    returnFunction = noCalibration

    originalValues = []
    actualValues = []
    csvFile = None
    path = os.path.dirname(os.path.abspath(__file__))
    configDir = &#39;{0}/settings/&#39;.format(path)
    filename = &#39;{0}{1}.{2}&#39;.format(configDir, which.upper(), self.color.lower())

    lastChecked = self.calibrationDataTime.get(which + &#34;_checked&#34;, 0)
    if ((int(time.time()) - lastChecked) &lt; DATA_REFRESH_WINDOW):
        # Only check every DATA_REFRESH_WINDOW seconds
        return None

    lastLoaded = self.calibrationDataTime.get(which, 0)
    self.calibrationDataTime[which + &#34;_checked&#34;] = int(time.time())

    try:
        if (os.path.isfile(filename)):
            fileModificationTime = os.path.getmtime(filename)
            if (lastLoaded &gt;= fileModificationTime):
                # No need to load, no change
                return None
            csvFile = open(filename, &#34;rb&#34;)
            csvFileReader = csv.reader(csvFile, skipinitialspace=True)
            self.calibrationDataTime[which] = fileModificationTime

            for row in csvFileReader:
                # Skip any blank or comment rows
                if (row != [] and row[0][:1] != &#34;#&#34;):
                    originalValues.append(float(row[0]))
                    actualValues.append(float(row[1]))
            # Close file
            csvFile.close()
    except IOError:
        print(&#39;Tilt ({0}): {1}: No calibration data ({2})&#39;.format(
            self.color, which.capitalize(), filename))
    except Exception as e:
        print(&#39;ERROR: Tilt ({0}): Unable to initialise {1} calibration data ({2}) - {3}&#39;.format(
            self.color, which.capitalize(), filename, e.message))
        # Attempt to close the file
        if (csvFile is not None):
            # Close file
            csvFile.close()

    # If more than two values, use interpolation
    if (len(actualValues) &gt;= 2):
        interpolationFunction = interp1d(originalValues, actualValues, bounds_error=False, fill_value=1)
        returnFunction = functools.partial(extrapolationCalibration, extrap1d(interpolationFunction))
        print(&#39;Tilt ({0}): Initialized {1} Calibration: Interpolation&#39;.format(self.color, which.capitalize()))
    # Not enough values. Likely just an offset calculation
    elif (len(actualValues) == 1):
        offset = actualValues[0] - originalValues[0]
        returnFunction = functools.partial(offsetCalibration, offset)
        print(&#39;Tilt ({0}): Initialized {1} Calibration: Offset ({2})&#39;.format(self.color, which.capitalize(),
                                                                             str(offset)))
    return returnFunction</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Tilt.TiltManager"><code class="flex name class">
<span>class <span class="ident">TiltManager</span></span>
<span>(</span><span>color, averagingPeriod=0, medianWindow=0, dev_id=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Manages the monitoring of all Tilts and storing the read values</p>
<p>Initializes TiltManager class with default values</p>
<p>:param color: Tilt color to be managed
:param averagingPeriod: Time period in seconds for noise smoothing
:param medianWindow: Median filter setting in number of
entries
:param dev_id: Device ID of the local Bluetooth device to use</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TiltManager:
    &#34;&#34;&#34;
    Manages the monitoring of all Tilts and storing the read values
    &#34;&#34;&#34;

    color = &#39;&#39;
    dev_id = 0
    averagingPeriod = 0
    medianWindow = 0
    tilt = None
    scanning = True
    tiltthread = None

    def __init__(self, color, averagingPeriod = 0, medianWindow = 0, dev_id = 0):
        &#34;&#34;&#34;
        Initializes TiltManager class with default values

        :param color: Tilt color to be managed
        :param averagingPeriod: Time period in seconds for noise smoothing
        :param medianWindow: Median filter setting in number of  entries
        :param dev_id: Device ID of the local Bluetooth device to use
        &#34;&#34;&#34;
        self.color = color
        self.dev_id = dev_id
        self.averagingPeriod = averagingPeriod
        self.medianWindow = medianWindow
        self.tilt = Tilt(color, self.averagingPeriod, self.medianWindow)

    def tiltName(self, uuid):
        &#34;&#34;&#34;
        Return Tilt color given UUID

        :param uuid: UUID from BLEacon
        :return: Tilt color
        &#34;&#34;&#34;

        return {
            &#39;a495bb10c5b14b44b5121370f02d74de&#39;: &#39;Red&#39;,
            &#39;a495bb20c5b14b44b5121370f02d74de&#39;: &#39;Green&#39;,
            &#39;a495bb30c5b14b44b5121370f02d74de&#39;: &#39;Black&#39;,
            &#39;a495bb40c5b14b44b5121370f02d74de&#39;: &#39;Purple&#39;,
            &#39;a495bb50c5b14b44b5121370f02d74de&#39;: &#39;Orange&#39;,
            &#39;a495bb60c5b14b44b5121370f02d74de&#39;: &#39;Blue&#39;,
            &#39;a495bb70c5b14b44b5121370f02d74de&#39;: &#39;Yellow&#39;,
            &#39;a495bb80c5b14b44b5121370f02d74de&#39;: &#39;Pink&#39;
        }.get(uuid)

    def storeValue(self, temperature, gravity):
        &#34;&#34;&#34;
        Store Tilt values

        :param temperature: Temperature value to be stored
        :param gravity: Gravity value to be stored
        :return: None
        &#34;&#34;&#34;

        self.tilt.setValues(temperature, gravity)

    def getValue(self):
        &#34;&#34;&#34;
        Retrieve Tilt value

        :return: Tilt value
        &#34;&#34;&#34;

        returnValue = None
        returnValue = self.tilt.getValues()
        return returnValue

    def scan(self):
        &#34;&#34;&#34;
        Scan for BLE messages, store as Tilt values

        :return: None
        &#34;&#34;&#34;

        try:
            sock = bluez.hci_open_dev(self.dev_id)

        except Exception as e:
            print(
                &#39;ERROR: Unable to access Bluetooth device: {0}&#39;.format(e.message))
            sys.exit(1)

        blescan.hci_le_set_scan_parameters(sock)
        blescan.hci_enable_le_scan(sock)

        # Keep scanning until the manager is told to stop.
        while self.scanning:

            returnedList = blescan.parse_events(sock, 10)

            for beacon in returnedList:
                beaconParts = beacon.split(&#34;,&#34;)

                # If the event is for our Tilt, process the data
                if self.tiltName(beaconParts[2]) == self.color:
                    # color = self.color
                    # ts = beaconParts[0]
                    # mac = beaconParts[1]
                    # uuid = beaconParts[2]
                    # temp = beaconParts[3]
                    # grav = beaconParts[4]
                    # txp = beaconParts[5]
                    # rssi = beaconParts[6]

                    # Get the temperature (in F, conversion in brewpi.py)
                    temperature = int(beaconParts[3])

                    # Get the gravity
                    gravity = float(beaconParts[4]) / 1000

                    # Store the retrieved values in the relevant Tilt object.
                    self.storeValue(temperature, gravity)

    def stop(self):
        &#34;&#34;&#34;
        Stop the BLE scanning thread
        :return:
        &#34;&#34;&#34;

        self.scanning = False

    def start(self):
        &#34;&#34;&#34;
        Starts the BLE scanning thread

        :return: None
        &#34;&#34;&#34;

        self.scanning = True
        self.tiltthread = thread.start_new_thread(self.scan, ())

    def loadSettings(self):
        &#34;&#34;&#34;
        Load Settings from config file

        Overrides values given at creation. This needs to be called before
        the start function is called.

        :return: None
        &#34;&#34;&#34;

        myDir = os.path.dirname(os.path.abspath(__file__))
        filename = &#39;{0}/settings/tiltsettings.ini&#39;.format(myDir)
        try:
            config = ConfigParser.ConfigParser()
            config.read(filename)

            # BT Device ID
            try:
                self.dev_id = config.getint(&#34;Manager&#34;, &#34;DeviceID&#34;)
            except:
                pass

            # Time period for noise smoothing
            try:
                self.averagingPeriod = config.getint(&#34;Manager&#34;, &#34;AvgWindow&#34;)
            except:
                pass

            # Median filter setting
            try:
                self.medianWindow = config.getint(&#34;Manager&#34;, &#34;MedWindow&#34;)
            except:
                pass

        except Exception as e:
            print(&#39;WARN: Config file does not exist or cannot be read: ({0}): {1}&#39;.format(filename, e.message))</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="Tilt.TiltManager.averagingPeriod"><code class="name">var <span class="ident">averagingPeriod</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="Tilt.TiltManager.color"><code class="name">var <span class="ident">color</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
<dt id="Tilt.TiltManager.dev_id"><code class="name">var <span class="ident">dev_id</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="Tilt.TiltManager.medianWindow"><code class="name">var <span class="ident">medianWindow</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="Tilt.TiltManager.scanning"><code class="name">var <span class="ident">scanning</span></code></dt>
<dd>
<section class="desc"><p>bool(x) -&gt; bool</p>
<p>Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.</p></section>
</dd>
<dt id="Tilt.TiltManager.tilt"><code class="name">var <span class="ident">tilt</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="Tilt.TiltManager.tiltthread"><code class="name">var <span class="ident">tiltthread</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Tilt.TiltManager.getValue"><code class="name flex">
<span>def <span class="ident">getValue</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieve Tilt value</p>
<p>:return: Tilt value</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getValue(self):
    &#34;&#34;&#34;
    Retrieve Tilt value

    :return: Tilt value
    &#34;&#34;&#34;

    returnValue = None
    returnValue = self.tilt.getValues()
    return returnValue</code></pre>
</details>
</dd>
<dt id="Tilt.TiltManager.loadSettings"><code class="name flex">
<span>def <span class="ident">loadSettings</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Load Settings from config file</p>
<p>Overrides values given at creation. This needs to be called before
the start function is called.</p>
<p>:return: None</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadSettings(self):
    &#34;&#34;&#34;
    Load Settings from config file

    Overrides values given at creation. This needs to be called before
    the start function is called.

    :return: None
    &#34;&#34;&#34;

    myDir = os.path.dirname(os.path.abspath(__file__))
    filename = &#39;{0}/settings/tiltsettings.ini&#39;.format(myDir)
    try:
        config = ConfigParser.ConfigParser()
        config.read(filename)

        # BT Device ID
        try:
            self.dev_id = config.getint(&#34;Manager&#34;, &#34;DeviceID&#34;)
        except:
            pass

        # Time period for noise smoothing
        try:
            self.averagingPeriod = config.getint(&#34;Manager&#34;, &#34;AvgWindow&#34;)
        except:
            pass

        # Median filter setting
        try:
            self.medianWindow = config.getint(&#34;Manager&#34;, &#34;MedWindow&#34;)
        except:
            pass

    except Exception as e:
        print(&#39;WARN: Config file does not exist or cannot be read: ({0}): {1}&#39;.format(filename, e.message))</code></pre>
</details>
</dd>
<dt id="Tilt.TiltManager.scan"><code class="name flex">
<span>def <span class="ident">scan</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Scan for BLE messages, store as Tilt values</p>
<p>:return: None</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scan(self):
    &#34;&#34;&#34;
    Scan for BLE messages, store as Tilt values

    :return: None
    &#34;&#34;&#34;

    try:
        sock = bluez.hci_open_dev(self.dev_id)

    except Exception as e:
        print(
            &#39;ERROR: Unable to access Bluetooth device: {0}&#39;.format(e.message))
        sys.exit(1)

    blescan.hci_le_set_scan_parameters(sock)
    blescan.hci_enable_le_scan(sock)

    # Keep scanning until the manager is told to stop.
    while self.scanning:

        returnedList = blescan.parse_events(sock, 10)

        for beacon in returnedList:
            beaconParts = beacon.split(&#34;,&#34;)

            # If the event is for our Tilt, process the data
            if self.tiltName(beaconParts[2]) == self.color:
                # color = self.color
                # ts = beaconParts[0]
                # mac = beaconParts[1]
                # uuid = beaconParts[2]
                # temp = beaconParts[3]
                # grav = beaconParts[4]
                # txp = beaconParts[5]
                # rssi = beaconParts[6]

                # Get the temperature (in F, conversion in brewpi.py)
                temperature = int(beaconParts[3])

                # Get the gravity
                gravity = float(beaconParts[4]) / 1000

                # Store the retrieved values in the relevant Tilt object.
                self.storeValue(temperature, gravity)</code></pre>
</details>
</dd>
<dt id="Tilt.TiltManager.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Starts the BLE scanning thread</p>
<p>:return: None</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#34;&#34;&#34;
    Starts the BLE scanning thread

    :return: None
    &#34;&#34;&#34;

    self.scanning = True
    self.tiltthread = thread.start_new_thread(self.scan, ())</code></pre>
</details>
</dd>
<dt id="Tilt.TiltManager.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Stop the BLE scanning thread
:return:</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    &#34;&#34;&#34;
    Stop the BLE scanning thread
    :return:
    &#34;&#34;&#34;

    self.scanning = False</code></pre>
</details>
</dd>
<dt id="Tilt.TiltManager.storeValue"><code class="name flex">
<span>def <span class="ident">storeValue</span></span>(<span>self, temperature, gravity)</span>
</code></dt>
<dd>
<section class="desc"><p>Store Tilt values</p>
<p>:param temperature: Temperature value to be stored
:param gravity: Gravity value to be stored
:return: None</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def storeValue(self, temperature, gravity):
    &#34;&#34;&#34;
    Store Tilt values

    :param temperature: Temperature value to be stored
    :param gravity: Gravity value to be stored
    :return: None
    &#34;&#34;&#34;

    self.tilt.setValues(temperature, gravity)</code></pre>
</details>
</dd>
<dt id="Tilt.TiltManager.tiltName"><code class="name flex">
<span>def <span class="ident">tiltName</span></span>(<span>self, uuid)</span>
</code></dt>
<dd>
<section class="desc"><p>Return Tilt color given UUID</p>
<p>:param uuid: UUID from BLEacon
:return: Tilt color</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tiltName(self, uuid):
    &#34;&#34;&#34;
    Return Tilt color given UUID

    :param uuid: UUID from BLEacon
    :return: Tilt color
    &#34;&#34;&#34;

    return {
        &#39;a495bb10c5b14b44b5121370f02d74de&#39;: &#39;Red&#39;,
        &#39;a495bb20c5b14b44b5121370f02d74de&#39;: &#39;Green&#39;,
        &#39;a495bb30c5b14b44b5121370f02d74de&#39;: &#39;Black&#39;,
        &#39;a495bb40c5b14b44b5121370f02d74de&#39;: &#39;Purple&#39;,
        &#39;a495bb50c5b14b44b5121370f02d74de&#39;: &#39;Orange&#39;,
        &#39;a495bb60c5b14b44b5121370f02d74de&#39;: &#39;Blue&#39;,
        &#39;a495bb70c5b14b44b5121370f02d74de&#39;: &#39;Yellow&#39;,
        &#39;a495bb80c5b14b44b5121370f02d74de&#39;: &#39;Pink&#39;
    }.get(uuid)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Tilt.TiltValue"><code class="flex name class">
<span>class <span class="ident">TiltValue</span></span>
<span>(</span><span>temperature, gravity)</span>
</code></dt>
<dd>
<section class="desc"><p>Holds all category values of an individual Tilt reading</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TiltValue:
    &#34;&#34;&#34;
    Holds all category values of an individual Tilt reading
    &#34;&#34;&#34;

    temperature = 0
    gravity = 0
    timestamp = 0

    def __init__(self, temperature, gravity):
        self.temperature = temperature
        self.gravity = gravity
        self.timestamp = datetime.datetime.now()

    def __str__(self):
        return &#34;T: &#34; + str(self.temperature) + &#34; G: &#34; + str(self.gravity)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="Tilt.TiltValue.gravity"><code class="name">var <span class="ident">gravity</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="Tilt.TiltValue.temperature"><code class="name">var <span class="ident">temperature</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="Tilt.TiltValue.timestamp"><code class="name">var <span class="ident">timestamp</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="Tilt.extrap1d" href="#Tilt.extrap1d">extrap1d</a></code></li>
<li><code><a title="Tilt.extrapolationCalibration" href="#Tilt.extrapolationCalibration">extrapolationCalibration</a></code></li>
<li><code><a title="Tilt.main" href="#Tilt.main">main</a></code></li>
<li><code><a title="Tilt.median" href="#Tilt.median">median</a></code></li>
<li><code><a title="Tilt.noCalibration" href="#Tilt.noCalibration">noCalibration</a></code></li>
<li><code><a title="Tilt.offsetCalibration" href="#Tilt.offsetCalibration">offsetCalibration</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Tilt.Tilt" href="#Tilt.Tilt">Tilt</a></code></h4>
<ul class="two-column">
<li><code><a title="Tilt.Tilt.averageValues" href="#Tilt.Tilt.averageValues">averageValues</a></code></li>
<li><code><a title="Tilt.Tilt.averagingPeriod" href="#Tilt.Tilt.averagingPeriod">averagingPeriod</a></code></li>
<li><code><a title="Tilt.Tilt.calibrate" href="#Tilt.Tilt.calibrate">calibrate</a></code></li>
<li><code><a title="Tilt.Tilt.calibrationDataTime" href="#Tilt.Tilt.calibrationDataTime">calibrationDataTime</a></code></li>
<li><code><a title="Tilt.Tilt.cleanValues" href="#Tilt.Tilt.cleanValues">cleanValues</a></code></li>
<li><code><a title="Tilt.Tilt.color" href="#Tilt.Tilt.color">color</a></code></li>
<li><code><a title="Tilt.Tilt.getValues" href="#Tilt.Tilt.getValues">getValues</a></code></li>
<li><code><a title="Tilt.Tilt.gravCal" href="#Tilt.Tilt.gravCal">gravCal</a></code></li>
<li><code><a title="Tilt.Tilt.gravityFunction" href="#Tilt.Tilt.gravityFunction">gravityFunction</a></code></li>
<li><code><a title="Tilt.Tilt.lock" href="#Tilt.Tilt.lock">lock</a></code></li>
<li><code><a title="Tilt.Tilt.medianValues" href="#Tilt.Tilt.medianValues">medianValues</a></code></li>
<li><code><a title="Tilt.Tilt.medianWindow" href="#Tilt.Tilt.medianWindow">medianWindow</a></code></li>
<li><code><a title="Tilt.Tilt.setValues" href="#Tilt.Tilt.setValues">setValues</a></code></li>
<li><code><a title="Tilt.Tilt.tempCal" href="#Tilt.Tilt.tempCal">tempCal</a></code></li>
<li><code><a title="Tilt.Tilt.tempFunction" href="#Tilt.Tilt.tempFunction">tempFunction</a></code></li>
<li><code><a title="Tilt.Tilt.tiltCal" href="#Tilt.Tilt.tiltCal">tiltCal</a></code></li>
<li><code><a title="Tilt.Tilt.values" href="#Tilt.Tilt.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Tilt.TiltManager" href="#Tilt.TiltManager">TiltManager</a></code></h4>
<ul class="two-column">
<li><code><a title="Tilt.TiltManager.averagingPeriod" href="#Tilt.TiltManager.averagingPeriod">averagingPeriod</a></code></li>
<li><code><a title="Tilt.TiltManager.color" href="#Tilt.TiltManager.color">color</a></code></li>
<li><code><a title="Tilt.TiltManager.dev_id" href="#Tilt.TiltManager.dev_id">dev_id</a></code></li>
<li><code><a title="Tilt.TiltManager.getValue" href="#Tilt.TiltManager.getValue">getValue</a></code></li>
<li><code><a title="Tilt.TiltManager.loadSettings" href="#Tilt.TiltManager.loadSettings">loadSettings</a></code></li>
<li><code><a title="Tilt.TiltManager.medianWindow" href="#Tilt.TiltManager.medianWindow">medianWindow</a></code></li>
<li><code><a title="Tilt.TiltManager.scan" href="#Tilt.TiltManager.scan">scan</a></code></li>
<li><code><a title="Tilt.TiltManager.scanning" href="#Tilt.TiltManager.scanning">scanning</a></code></li>
<li><code><a title="Tilt.TiltManager.start" href="#Tilt.TiltManager.start">start</a></code></li>
<li><code><a title="Tilt.TiltManager.stop" href="#Tilt.TiltManager.stop">stop</a></code></li>
<li><code><a title="Tilt.TiltManager.storeValue" href="#Tilt.TiltManager.storeValue">storeValue</a></code></li>
<li><code><a title="Tilt.TiltManager.tilt" href="#Tilt.TiltManager.tilt">tilt</a></code></li>
<li><code><a title="Tilt.TiltManager.tiltName" href="#Tilt.TiltManager.tiltName">tiltName</a></code></li>
<li><code><a title="Tilt.TiltManager.tiltthread" href="#Tilt.TiltManager.tiltthread">tiltthread</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Tilt.TiltValue" href="#Tilt.TiltValue">TiltValue</a></code></h4>
<ul class="">
<li><code><a title="Tilt.TiltValue.gravity" href="#Tilt.TiltValue.gravity">gravity</a></code></li>
<li><code><a title="Tilt.TiltValue.temperature" href="#Tilt.TiltValue.temperature">temperature</a></code></li>
<li><code><a title="Tilt.TiltValue.timestamp" href="#Tilt.TiltValue.timestamp">timestamp</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>